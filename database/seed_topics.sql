-- Seed Data for DSA Subject
-- Run this after migrations.sql

-- Insert DSA subject
INSERT INTO public.subjects (id, code, name, description, total_topics) VALUES
    ('11111111-1111-1111-1111-111111111111', 'DSA', 'Data Structures & Algorithms', 'Master fundamental data structures and algorithmic problem solving', 12)
ON CONFLICT (code) DO NOTHING;

-- Insert DSA topics with prerequisites and graph positions
INSERT INTO public.topics (id, subject_id, slug, title, description, content, difficulty, prerequisites, graph_position) VALUES
    -- Row 1: Fundamentals
    ('a1111111-1111-1111-1111-111111111111', '11111111-1111-1111-1111-111111111111', 'arrays', 'Arrays', 'Foundation of data structures', 
     '# Arrays\n\nArrays are the most fundamental data structure in programming. They store elements of the same type in contiguous memory locations.\n\n## Key Concepts\n- **Fixed Size**: Arrays have a predetermined size\n- **Index-Based Access**: O(1) time to access any element\n- **Memory Layout**: Elements stored sequentially in memory\n\n## Common Operations\n```python\n# Array declaration\narr = [1, 2, 3, 4, 5]\n\n# Access element\nprint(arr[0])  # Output: 1\n\n# Update element\narr[2] = 10\n\n# Iterate\nfor num in arr:\n    print(num)\n```\n\n## Time Complexity\n- Access: O(1)\n- Search: O(n)\n- Insert/Delete: O(n)', 
     'beginner', '{}', '{"x": 100, "y": 100}'),
    
    ('a2222222-2222-2222-2222-222222222222', '11111111-1111-1111-1111-111111111111', 'linked-lists', 'Linked Lists', 'Dynamic linear data structure', 
     '# Linked Lists\n\nA linked list is a linear data structure where elements are stored in nodes. Each node contains data and a reference to the next node.\n\n## Types\n- **Singly Linked List**: One directional link\n- **Doubly Linked List**: Bidirectional links\n- **Circular Linked List**: Last node points to first\n\n## Implementation\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def insert(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n```\n\n## Time Complexity\n- Access: O(n)\n- Search: O(n)\n- Insert at head: O(1)\n- Delete: O(n)', 
     'beginner', '{}', '{"x": 300, "y": 100}'),
    
    ('a3333333-3333-3333-3333-333333333333', '11111111-1111-1111-1111-111111111111', 'recursion', 'Recursion', 'Function calling itself', 
     '# Recursion\n\nRecursion is a programming technique where a function calls itself to solve smaller instances of the same problem.\n\n## Key Components\n1. **Base Case**: Condition to stop recursion\n2. **Recursive Case**: Function calls itself\n\n## Classic Example: Factorial\n```python\ndef factorial(n):\n    # Base case\n    if n == 0 or n == 1:\n        return 1\n    # Recursive case\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # Output: 120\n```\n\n## Fibonacci Sequence\n```python\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n```\n\n## Important Points\n- Always define a base case\n- Watch out for stack overflow\n- Consider iterative alternatives for better space complexity', 
     'beginner', '{}', '{"x": 500, "y": 100}'),
    
    -- Row 2: Linear Structures
    ('a4444444-4444-4444-4444-444444444444', '11111111-1111-1111-1111-111111111111', 'stacks', 'Stacks', 'LIFO data structure', 
     '# Stacks\n\nA stack is a Last-In-First-Out (LIFO) data structure. Think of it like a stack of plates.\n\n## Core Operations\n- **Push**: Add element to top - O(1)\n- **Pop**: Remove element from top - O(1)\n- **Peek**: View top element - O(1)\n\n## Implementation\n```python\nclass Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n    \n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n    \n    def is_empty(self):\n        return len(self.items) == 0\n```\n\n## Use Cases\n- Function call stack\n- Undo/Redo operations\n- Bracket matching\n- Expression evaluation', 
     'beginner', ARRAY['a1111111-1111-1111-1111-111111111111']::UUID[], '{"x": 100, "y": 250}'),
    
    ('a5555555-5555-5555-5555-555555555555', '11111111-1111-1111-1111-111111111111', 'queues', 'Queues', 'FIFO data structure', 
     '# Queues\n\nA queue is a First-In-First-Out (FIFO) data structure. Like a line of people waiting.\n\n## Core Operations\n- **Enqueue**: Add to rear - O(1)\n- **Dequeue**: Remove from front - O(1)\n- **Front**: View front element - O(1)\n\n## Implementation\n```python\nfrom collections import deque\n\nclass Queue:\n    def __init__(self):\n        self.items = deque()\n    \n    def enqueue(self, item):\n        self.items.append(item)\n    \n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.popleft()\n    \n    def front(self):\n        if not self.is_empty():\n            return self.items[0]\n    \n    def is_empty(self):\n        return len(self.items) == 0\n```\n\n## Types\n- Simple Queue\n- Circular Queue\n- Priority Queue\n- Double-Ended Queue (Deque)', 
     'beginner', ARRAY['a1111111-1111-1111-1111-111111111111']::UUID[], '{"x": 300, "y": 250}'),
    
    -- Row 3: Tree Structures
    ('a6666666-6666-6666-6666-666666666666', '11111111-1111-1111-1111-111111111111', 'binary-trees', 'Binary Trees', 'Hierarchical tree structure', 
     '# Binary Trees\n\nA binary tree is a hierarchical data structure where each node has at most two children (left and right).\n\n## Types\n- **Full Binary Tree**: Every node has 0 or 2 children\n- **Complete Binary Tree**: All levels filled except possibly the last\n- **Perfect Binary Tree**: All internal nodes have 2 children\n\n## Implementation\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n# Traversals\ndef inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.val)\n        inorder(root.right)\n\ndef preorder(root):\n    if root:\n        print(root.val)\n        preorder(root.left)\n        preorder(root.right)\n\ndef postorder(root):\n    if root:\n        postorder(root.left)\n        postorder(root.right)\n        print(root.val)\n```\n\n## Time Complexity\n- Search: O(n)\n- Insert: O(n)\n- Delete: O(n)', 
     'intermediate', ARRAY['a3333333-3333-3333-3333-333333333333']::UUID[], '{"x": 100, "y": 400}'),
    
    ('a7777777-7777-7777-7777-777777777777', '11111111-1111-1111-1111-111111111111', 'bst', 'Binary Search Trees', 'Ordered binary tree', 
     '# Binary Search Trees (BST)\n\nA BST is a binary tree where for each node:\n- Left subtree contains only nodes with values less than the node\n- Right subtree contains only nodes with values greater than the node\n\n## Properties\n- Inorder traversal gives sorted sequence\n- Efficient search, insert, delete operations\n\n## Implementation\n```python\nclass BST:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def insert(self, val):\n        if val < self.val:\n            if self.left is None:\n                self.left = BST(val)\n            else:\n                self.left.insert(val)\n        else:\n            if self.right is None:\n                self.right = BST(val)\n            else:\n                self.right.insert(val)\n    \n    def search(self, val):\n        if val == self.val:\n            return True\n        elif val < self.val:\n            return self.left.search(val) if self.left else False\n        else:\n            return self.right.search(val) if self.right else False\n```\n\n## Time Complexity\n- Average: O(log n)\n- Worst: O(n) - unbalanced tree', 
     'intermediate', ARRAY['a6666666-6666-6666-6666-666666666666']::UUID[], '{"x": 300, "y": 400}'),
    
    -- Row 4: Graphs and Sorting
    ('a8888888-8888-8888-8888-888888888888', '11111111-1111-1111-1111-111111111111', 'graphs', 'Graphs', 'Network of connected nodes', 
     '# Graphs\n\nA graph is a collection of nodes (vertices) connected by edges.\n\n## Types\n- **Directed vs Undirected**\n- **Weighted vs Unweighted**\n- **Cyclic vs Acyclic**\n\n## Representation\n```python\n# Adjacency List\ngraph = {\n    ''A'': [''B'', ''C''],\n    ''B'': [''A'', ''D''],\n    ''C'': [''A'', ''D''],\n    ''D'': [''B'', ''C'']\n}\n\n# Adjacency Matrix\ngraph = [\n    [0, 1, 1, 0],\n    [1, 0, 0, 1],\n    [1, 0, 0, 1],\n    [0, 1, 1, 0]\n]\n```\n\n## Graph Traversals\n```python\n# BFS\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n\n# DFS\ndef dfs(graph, node, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n```', 
     'intermediate', ARRAY['a6666666-6666-6666-6666-666666666666']::UUID[], '{"x": 500, "y": 400}'),
    
    ('a9999999-9999-9999-9999-999999999999', '11111111-1111-1111-1111-111111111111', 'sorting', 'Sorting Algorithms', 'Arranging data in order', 
     '# Sorting Algorithms\n\nSorting is the process of arranging elements in a specific order.\n\n## Common Algorithms\n\n### Bubble Sort - O(n²)\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n```\n\n### Quick Sort - O(n log n) average\n```python\ndef quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quick_sort(left) + middle + quick_sort(right)\n```\n\n### Merge Sort - O(n log n)\n```python\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n```\n\n## Comparison\n| Algorithm | Best | Average | Worst | Space |\n|-----------|------|---------|-------|-------|\n| Bubble | O(n) | O(n²) | O(n²) | O(1) |\n| Quick | O(n log n) | O(n log n) | O(n²) | O(log n) |\n| Merge | O(n log n) | O(n log n) | O(n log n) | O(n) |', 
     'intermediate', ARRAY['a1111111-1111-1111-1111-111111111111', 'a3333333-3333-3333-3333-333333333333']::UUID[], '{"x": 100, "y": 550}'),
    
    ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', '11111111-1111-1111-1111-111111111111', 'searching', 'Searching Algorithms', 'Finding elements efficiently', 
     '# Searching Algorithms\n\nSearching algorithms help us find elements in data structures.\n\n## Linear Search - O(n)\n```python\ndef linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n```\n\n## Binary Search - O(log n)\nRequires sorted array!\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# Recursive version\ndef binary_search_recursive(arr, target, left, right):\n    if left > right:\n        return -1\n    mid = (left + right) // 2\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search_recursive(arr, target, mid + 1, right)\n    else:\n        return binary_search_recursive(arr, target, left, mid - 1)\n```\n\n## Comparison\n- Linear: Works on any array, O(n)\n- Binary: Requires sorted array, O(log n)', 
     'intermediate', ARRAY['a9999999-9999-9999-9999-999999999999']::UUID[], '{"x": 300, "y": 550}'),
    
    -- Row 5: Advanced
    ('abbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb', '11111111-1111-1111-1111-111111111111', 'hashing', 'Hash Tables', 'Fast key-value lookups', 
     '# Hash Tables\n\nHash tables provide O(1) average-case lookup, insert, and delete operations.\n\n## How It Works\n1. Hash function converts key to index\n2. Store value at that index\n3. Handle collisions\n\n## Implementation\n```python\nclass HashTable:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n    \n    def _hash(self, key):\n        return hash(key) % self.size\n    \n    def insert(self, key, value):\n        index = self._hash(key)\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index][i] = (key, value)\n                return\n        self.table[index].append((key, value))\n    \n    def get(self, key):\n        index = self._hash(key)\n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        return None\n```\n\n## Collision Resolution\n- **Chaining**: Store multiple items at same index\n- **Open Addressing**: Find next available slot\n\n## Python Dict\n```python\n# Built-in hash table\nmy_dict = {}\nmy_dict[''key''] = ''value''\nprint(my_dict[''key''])  # O(1) lookup\n```', 
     'intermediate', ARRAY['a1111111-1111-1111-1111-111111111111']::UUID[], '{"x": 500, "y": 550}'),
    
    ('acccccccc-cccc-cccc-cccc-cccccccccccc', '11111111-1111-1111-1111-111111111111', 'dynamic-programming', 'Dynamic Programming', 'Optimize with memoization', 
     '# Dynamic Programming (DP)\n\nDP solves complex problems by breaking them into simpler subproblems and storing results.\n\n## Approaches\n1. **Memoization** (Top-Down): Recursion + caching\n2. **Tabulation** (Bottom-Up): Iterative approach\n\n## Fibonacci with DP\n```python\n# Memoization\ndef fib_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)\n    return memo[n]\n\n# Tabulation\ndef fib_tab(n):\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n```\n\n## Classic DP Problems\n\n### Longest Common Subsequence\n```python\ndef lcs(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]\n```\n\n### 0/1 Knapsack\n```python\ndef knapsack(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(\n                    values[i-1] + dp[i-1][w-weights[i-1]],\n                    dp[i-1][w]\n                )\n            else:\n                dp[i][w] = dp[i-1][w]\n    return dp[n][capacity]\n```', 
     'advanced', ARRAY['a3333333-3333-3333-3333-333333333333']::UUID[], '{"x": 100, "y": 700}')
ON CONFLICT (slug) DO NOTHING;

-- Update subject total_topics count
UPDATE public.subjects 
SET total_topics = (SELECT COUNT(*) FROM public.topics WHERE subject_id = '11111111-1111-1111-1111-111111111111')
WHERE id = '11111111-1111-1111-1111-111111111111';
